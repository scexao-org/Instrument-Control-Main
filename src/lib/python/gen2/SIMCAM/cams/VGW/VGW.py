#
# VGW.py -- personality for VGW instrument
#
#[ Eric Jeschke (eric@naoj.org) --
#  Last edit: Mon Apr 15 17:28:30 HST 2013
#]
#
"""This file implements VGW subsystem and commands.
"""
import sys, time, os
import re, glob
import threading, Queue
import types
import math

import remoteObjects as ro
from SIMCAM import BASECAM, CamError, CamCommandError, CamInterfaceError
import SIMCAM.cams.common as common
from SOSS.SOSSrpc import time2timestamp
import astro.fitsutils as fitsutils
import astro.radec as radec
import astro.fitsheader as fitsheader
import Bunch
import SOSS.GuiderInt.Ag as Ag
import SOSS.GuiderInt.guiderfitsheader as gfh
import cfg.g2soss as g2soss
from ginga.misc import Task

# local imports
import AgData
import AgGUI


class VGWError(CamError):
    pass

class VGWCommandError(CamCommandError):
    pass

class VGW(BASECAM):

    def __init__(self, logger, env, ev_quit=None):

        self.logger = logger
        self.env = env
        # Convoluted but sure way of getting this module's directory
        self.mydir = os.path.split(sys.modules[__name__].__file__)[0]

        if not ev_quit:
            self.ev_quit = threading.Event()
        else:
            self.ev_quit = ev_quit

        self.lock = threading.RLock()

        self.ocs = None
        self.mystatus = None

        # Thread-safe bunch for storing parameters read/written
        # by threads executing in this object
        self.param = Bunch.threadSafeBunch()
        self.param.fitsdir = '/tmp'
        
        # Interval between status packets (secs)
        self.param.status_interval = 10

        # Mode instrument is in: 'local' or 'slave'
        self.mode = 'slave'

        self.viewerName = 'guideview'
        
        # helper object to make our FITS headers from definitions
        self.fitshelper = gfh.GuiderFitsHeaderMaker(self.logger)
                                                     
        # VGW pulls status in sets.  These are the known sets.
        self.statusset = Bunch.Bunch()
        # OCS aliases necessary to build any AG header
        self.statusset.OBJECT = self.fitshelper.get_statusAliases()

        # Status aliases needed for finding out about centroid calculation
        self.statusset.DETECT = set([
            'TSCV.AGCCalc', 'TSCV.AGCCalcRegX11', 'TSCV.AGCCalcRegY11',
            'TSCV.AGCCalcRegX21', 'TSCV.AGCCalcRegY21', 'TSCV.AGCCalcRegX12',
            'TSCV.AGCCalcRegY12', 'TSCV.AGCCalcRegX22', 'TSCV.AGCCalcRegY22',
            'TSCV.SVCCalc', 'TSCV.SVCCalcRegX11', 'TSCV.SVCCalcRegY11',
            'TSCV.SVCCalcRegX21', 'TSCV.SVCCalcRegY21', 'TSCV.SVCCalcRegX12',
            'TSCV.SVCCalcRegY12', 'TSCV.SVCCalcRegX22', 'TSCV.SVCCalcRegY22',
            ])

        # For SV centroid detection
        ## self.svdetect_mode = 'OFF'
        ## self.svdetect_ra = None
        ## self.svdetect_dec = None

        # The set of all status values we are interested in
        self.statusset.ALL = set([])
        for key in self.statusset.keys():
            self.statusset.ALL = self.statusset.ALL.union(self.statusset[key])
            
        # Holds most recent values from the OCS
        self.ocsstatus = {}

        self.datakinds = ('object', 'dark', 'flat', 'sky', 'bias')

        
    #######################################
    # INITIALIZATION
    #######################################

    def initialize(self, ocsint):
        '''Initialize instrument.  
        '''
        # Grab my handle to the OCS interface.
        self.ocs = ocsint

        # Thread pool for autonomous tasks
        self.threadPool = self.ocs.threadPool
        
        # For task inheritance:
        self.tag = 'VGW'
        self.shares = ['logger', 'ev_quit', 'threadPool', 'param']

        # Holds our status tables, etc.
        self.stat = Bunch.Bunch()
        
        # Used to format status buffer (item lengths must match definitions
        # of status aliases on SOSS side in $OSS_SYSTEM/StatusAlias.pro)

        # Autogenerated on Tue Dec 14 15:35:16 2010 by pro2fmt.py
        # Aliases for table VGWD:
        #   Off  Len T Alias                                             
        # Skipping invalid alias: VGW.QDAS.TEL.DATE
        # Skipping invalid alias: VGWD.DATE
        #     0    8 s VGWD.RUN1                                         
        #     8    1   padding
        #     9    8 s VGWD.RUN2                                         
        #    17   51   padding
        #    68   10 d VGWD.DISP.AG                                      
        #    78   29   padding
        #   107    8 s VGW.SVCalibFlat                                   
        # Overlapping alias offset: 107 (VGW.SVCalibSky)
        # Overlapping alias offset: 107 (VGW.SVCalibDark)
        #   115    1   padding
        #   116   10 d VGWD.DISP.SV                                      
        #   126   38   padding
        #   164   10 d VGWD.DISP.SH                                      
        #   174   73   padding
        #   247    4 s VGWD.FWHM.FLG.AG                                  
        #   251    1   padding
        #   252   10 f VGWD.FWHM.AG                                      
        #   262    1   padding
        #   263   18 s VGWD.FWHM.TIME.AG                                 
        #   281    1   padding
        #   282    4 s VGWD.SVCCALC                                      
        #   286    1   padding
        #   287    4 s VGWD.FWHM.FLG.SV                                  
        #   291    1   padding
        #   292   10 f VGWD.FWHM.SV                                      
        #   302    1   padding
        #   303   18 s VGWD.FWHM.TIME.SV                                 

        # Format string:
        fmt_VGWD = "%(run1)8.8s,%(run2)8.8s,                                                  %(disp_ag)10d,                            %(svcalibflat)8.8s,%(disp_sv)10d,                                     %(disp_sh)10d,                                                                        %(fwhm_flg_ag)4.4s,%(fwhm_ag)10.4f,%(fwhm_time_ag)18.18s,%(svccalc)4.4s,%(fwhm_flg_sv)4.4s,%(fwhm_sv)10.4f,%(fwhm_time_sv)18.18s"

        map_VGWD = dict([('VGWD.RUN1', 'run1'), ('VGWD.RUN2', 'run2'), ('VGWD.DISP.AG', 'disp_ag'), ('VGWD.SVCALIBFLAT', 'svcalibflat'), ('VGWD.DISP.SV', 'disp_sv'), ('VGWD.DISP.SH', 'disp_sh'), ('VGWD.FWHM.FLG.AG', 'fwhm_flg_ag'), ('VGWD.FWHM.AG', 'fwhm_ag'), ('VGWD.FWHM.TIME.AG', 'fwhm_time_ag'), ('VGWD.SVCCALC', 'svccalc'), ('VGWD.FWHM.FLG.SV', 'fwhm_flg_sv'), ('VGWD.FWHM.SV', 'fwhm_sv'), ('VGWD.FWHM.TIME.SV', 'fwhm_time_sv')])
        
        # Register our table:
        self.stat.VGWD = self.ocs.addStatusTable('VGWD', ['run1', 'run2', 'disp_ag', 'svcalibflat', 'disp_sv', 'disp_sh', 'fwhm_flg_ag', 'fwhm_ag', 'fwhm_time_ag', 'svccalc', 'fwhm_flg_sv', 'fwhm_sv', 'fwhm_time_sv'], fmt_VGWD, map_VGWD)

        # Set initial values
        self.ocs.setStatus('VGWD', run1=self.mode.upper(), run2='NORMAL',
                           disp_ag=0, fwhm_flg_ag='ON', fwhm_ag=0.0, fwhm_time_ag='',
                           disp_sv=0, fwhm_flg_sv='ON', fwhm_sv=0.0, fwhm_time_sv='',
                           svcalibflat='', svccalc='ON', 
                           disp_sh=0)

        # Autogenerated on Tue Dec 14 15:37:02 2010 by pro2fmt.py
        # Aliases for table VGWQ:
        #   Off  Len T Alias                                             
        #     0   38   padding
        #    38   11 s VGWQ.AGP.REL.RA                                   
        #    49    1   padding
        #    50   10 s VGWQ.AGP.REL.DEC                                  
        #    60    1   padding
        #    61    6 f VGWQ.AGP.EQUINOX                                  
        #    67    1   padding
        #    68   10 s VGWQ.AGP.ABS.RA                                   
        #    78    1   padding
        #    79   10 s VGWQ.AGP.ABS.DEC                                  
        #    89    1   padding
        #    90    4 f VGWQ.AGP.MAG                                      
        #    94    1   padding
        #    95   30 s VGWQ.AGP.OBJECT                                   
        #   125   41   padding
        #   166   11 s VGWQ.SVP.REL.RA                                   
        #   177    1   padding
        #   178   10 s VGWQ.SVP.REL.DEC                                  
        #   188    1   padding
        #   189    6 f VGWQ.SVP.EQUINOX                                  
        #   195    1   padding
        #   196   10 s VGWQ.SVP.ABS.RA                                   
        #   206    1   padding
        #   207   10 s VGWQ.SVP.ABS.DEC                                  
        #   217    1   padding
        #   218    6 f VGWQ.SVP.ABS.MM                                   
        #   224   70   padding
        #   294   11 s VGWQ.SVTM.REL.RA                                  
        #   305    1   padding
        #   306   10 s VGWQ.SVTM.REL.DEC                                 
        #   316    1   padding
        #   317    6 f VGWQ.SVTM.DST.EQUINOX                             
        # Overlapping alias offset: 317 (VGWQ.SVTM.EQUINOX)
        # Overlapping alias offset: 317 (VGWQ.SVTM.TGT.EQUINOX)
        #   323    1   padding
        #   324   10 s VGWQ.SVTM.TGT.RA                                  
        #   334    1   padding
        #   335   10 s VGWQ.SVTM.TGT.DEC                                 
        #   345    1   padding
        #   346    5 f VGWQ.SVTM.TGT.X                                   
        #   351    1   padding
        #   352    5 f VGWQ.SVTM.TGT.Y                                   
        #   357    1   padding
        #   358   10 s VGWQ.SVTM.DST.RA                                  
        #   368    1   padding
        #   369   10 s VGWQ.SVTM.DST.DEC                                 
        #   379    1   padding
        #   380    5 f VGWQ.SVTM.DST.X                                   
        #   385    1   padding
        #   386    5 f VGWQ.SVTM.DST.Y                                   
        #   391   31   padding
        #   422    4 d VGWQ.AGE.X1                                       
        #   426    1   padding
        #   427    4 d VGWQ.AGE.Y1                                       
        #   431    1   padding
        #   432    4 d VGWQ.AGE.X2                                       
        #   436    1   padding
        #   437    4 d VGWQ.AGE.Y2                                       
        #   441    1   padding
        #   442    8 d VGWQ.AGE.EXPTIME                                  
        #   450    1   padding
        #   451   10 f VGWQ.AGE.FWHM                                     
        #   461    1   padding
        #   462   10 f VGWQ.AGE.BRIGHT                                   
        #   472    1   padding
        #   473   10 f VGWQ.AGE.SKYLVL                                   
        #   483    1   padding
        #   484    6 f VGWQ.AGE.OBJX                                     
        #   490    1   padding
        #   491    6 f VGWQ.AGE.OBJY                                     
        #   497   53   padding
        #   550    4 d VGWQ.AGG1.X1                                      
        #   554    1   padding
        #   555    4 d VGWQ.AGG1.Y1                                      
        #   559    1   padding
        #   560    4 d VGWQ.AGG1.X2                                      
        #   564    1   padding
        #   565    4 d VGWQ.AGG1.Y2                                      
        #   569    1   padding
        #   570    4 d VGWQ.AGG2.X1                                      
        #   574    1   padding
        #   575    4 d VGWQ.AGG2.Y1                                      
        #   579    1   padding
        #   580    4 d VGWQ.AGG2.X2                                      
        #   584    1   padding
        #   585    4 d VGWQ.AGG2.Y2                                      
        #   589    1   padding
        #   590   10 f VGWQ.AGG.FWHM                                     
        #   600    1   padding
        #   601   10 f VGWQ.AGG.BRIGHT                                   
        #   611    1   padding
        #   612   10 f VGWQ.AGG.SKYLVL                                   
        #   622    1   padding
        #   623    6 f VGWQ.AGG.OBJX                                     
        #   629    1   padding
        #   630    6 f VGWQ.AGG.OBJY                                     
        #   636   42   padding
        #   678    4 d VGWQ.SVG.X1                                       
        #   682    1   padding
        #   683    4 d VGWQ.SVG.Y1                                       
        #   687    1   padding
        #   688    4 d VGWQ.SVG.X2                                       
        #   692    1   padding
        #   693    4 d VGWQ.SVG.Y2                                       
        #   697    1   padding
        #   698   10 f VGWQ.SVG.FWHM                                     
        #   708    1   padding
        #   709   10 f VGWQ.SVG.BRIGHT                                   
        #   719    1   padding
        #   720   10 f VGWQ.SVG.SKYLVL                                   
        #   730    1   padding
        #   731    6 f VGWQ.SVG.OBJX                                     
        #   737    1   padding
        #   738    6 f VGWQ.SVG.OBJY                                     
        #   744   62   padding
        #   806    4 d VGWQ.SVE.X1                                       
        #   810    1   padding
        #   811    4 d VGWQ.SVE.Y1                                       
        #   815    1   padding
        #   816    4 d VGWQ.SVE.X2                                       
        #   820    1   padding
        #   821    4 d VGWQ.SVE.Y2                                       
        #   825    1   padding
        #   826    8 d VGWQ.SVE.EXPTIME                                  
        #   834    1   padding
        #   835   10 f VGWQ.SVE.FWHM                                     
        #   845    1   padding
        #   846   10 f VGWQ.SVE.BRIGHT                                   
        #   856    1   padding
        #   857   10 f VGWQ.SVE.SKYLVL                                   
        #   867    1   padding
        #   868    6 f VGWQ.SVE.OBJX                                     
        #   874    1   padding
        #   875    6 f VGWQ.SVE.OBJY                                     
        #   881   24   padding
        #   905   18 s VGWQ.SVGSR.DATE                                   
        #   923    1   padding
        #   924    2 s VGWQ.SVGSR.RESULT                                 
        #   926    8   padding
        #   934   11 s VGWQ.SVGSR.REL.RA                                 
        #   945    1   padding
        #   946   10 s VGWQ.SVGSR.REL.DEC                                
        #   956  106   padding
        #  1062   10 s VGWQ.SHG.ABS.RA                                   
        #  1072    1   padding
        #  1073   10 s VGWQ.SHG.ABS.DEC                                  
        #  1083    1   padding
        #  1084    6 f VGWQ.SHG.EQUINOX                                  
        #  1090    1   padding
        #  1091    8 d VGWQ.SHG.EXPTIME_AG                               
        #  1099    1   padding
        #  1100    8 d VGWQ.SHG.EXPTIME_SH
        
        # Format string:
        fmt_VGWQ = ",                                     %(agp_rel_ra)11.11s,%(agp_rel_dec)10.10s,%(agp_equinox)6.4f,%(agp_abs_ra)10.10s,%(agp_abs_dec)10.10s,%(agp_mag)4.4f,%(agp_object)30.30s,                                        %(svp_rel_ra)11.11s,%(svp_rel_dec)10.10s,%(svp_equinox)6.4f,%(svp_abs_ra)10.10s,%(svp_abs_dec)10.10s,%(svp_abs_mm)6.4f,                                                                     %(svtm_rel_ra)11.11s,%(svtm_rel_dec)10.10s,%(svtm_dst_equinox)6.4f,%(svtm_tgt_ra)10.10s,%(svtm_tgt_dec)10.10s,%(svtm_tgt_x)5.4f,%(svtm_tgt_y)5.4f,%(svtm_dst_ra)10.10s,%(svtm_dst_dec)10.10s,%(svtm_dst_x)5.4f,%(svtm_dst_y)5.4f,                              %(age_x1)4d,%(age_y1)4d,%(age_x2)4d,%(age_y2)4d,%(age_exptime)8d,%(age_fwhm)10.4f,%(age_bright)10.4f,%(age_skylvl)10.4f,%(age_objx)6.4f,%(age_objy)6.4f,                                                    %(agg1_x1)4d,%(agg1_y1)4d,%(agg1_x2)4d,%(agg1_y2)4d,%(agg2_x1)4d,%(agg2_y1)4d,%(agg2_x2)4d,%(agg2_y2)4d,%(agg_fwhm)10.4f,%(agg_bright)10.4f,%(agg_skylvl)10.4f,%(agg_objx)6.4f,%(agg_objy)6.4f,                                         %(svg_x1)4d,%(svg_y1)4d,%(svg_x2)4d,%(svg_y2)4d,%(svg_fwhm)10.4f,%(svg_bright)10.4f,%(svg_skylvl)10.4f,%(svg_objx)6.4f,%(svg_objy)6.4f,                                                             %(sve_x1)4d,%(sve_y1)4d,%(sve_x2)4d,%(sve_y2)4d,%(sve_exptime)8d,%(sve_fwhm)10.4f,%(sve_bright)10.4f,%(sve_skylvl)10.4f,%(sve_objx)6.4f,%(sve_objy)6.4f,                       %(svgsr_date)18.18s,%(svgsr_result)2.2s,       %(svgsr_rel_ra)11.11s,%(svgsr_rel_dec)10.10s,                                                                                                         %(shg_abs_ra)10.10s,%(shg_abs_dec)10.10s,%(shg_equinox)6.4f,%(shg_exptime_ag)8d,%(shg_exptime_sh)8d"

        map_VGWQ = dict([('VGWQ.AGP.REL.RA', 'agp_rel_ra'), ('VGWQ.AGP.REL.DEC', 'agp_rel_dec'), ('VGWQ.AGP.EQUINOX', 'agp_equinox'), ('VGWQ.AGP.ABS.RA', 'agp_abs_ra'), ('VGWQ.AGP.ABS.DEC', 'agp_abs_dec'), ('VGWQ.AGP.MAG', 'agp_mag'), ('VGWQ.AGP.OBJECT', 'agp_object'), ('VGWQ.SVP.REL.RA', 'svp_rel_ra'), ('VGWQ.SVP.REL.DEC', 'svp_rel_dec'), ('VGWQ.SVP.EQUINOX', 'svp_equinox'), ('VGWQ.SVP.ABS.RA', 'svp_abs_ra'), ('VGWQ.SVP.ABS.DEC', 'svp_abs_dec'), ('VGWQ.SVP.ABS.MM', 'svp_abs_mm'), ('VGWQ.SVTM.REL.RA', 'svtm_rel_ra'), ('VGWQ.SVTM.REL.DEC', 'svtm_rel_dec'), ('VGWQ.SVTM.DST.EQUINOX', 'svtm_dst_equinox'), ('VGWQ.SVTM.TGT.RA', 'svtm_tgt_ra'), ('VGWQ.SVTM.TGT.DEC', 'svtm_tgt_dec'), ('VGWQ.SVTM.TGT.X', 'svtm_tgt_x'), ('VGWQ.SVTM.TGT.Y', 'svtm_tgt_y'), ('VGWQ.SVTM.DST.RA', 'svtm_dst_ra'), ('VGWQ.SVTM.DST.DEC', 'svtm_dst_dec'), ('VGWQ.SVTM.DST.X', 'svtm_dst_x'), ('VGWQ.SVTM.DST.Y', 'svtm_dst_y'), ('VGWQ.AGE.X1', 'age_x1'), ('VGWQ.AGE.Y1', 'age_y1'), ('VGWQ.AGE.X2', 'age_x2'), ('VGWQ.AGE.Y2', 'age_y2'), ('VGWQ.AGE.EXPTIME', 'age_exptime'), ('VGWQ.AGE.FWHM', 'age_fwhm'), ('VGWQ.AGE.BRIGHT', 'age_bright'), ('VGWQ.AGE.SKYLVL', 'age_skylvl'), ('VGWQ.AGE.OBJX', 'age_objx'), ('VGWQ.AGE.OBJY', 'age_objy'), ('VGWQ.AGG1.X1', 'agg1_x1'), ('VGWQ.AGG1.Y1', 'agg1_y1'), ('VGWQ.AGG1.X2', 'agg1_x2'), ('VGWQ.AGG1.Y2', 'agg1_y2'), ('VGWQ.AGG2.X1', 'agg2_x1'), ('VGWQ.AGG2.Y1', 'agg2_y1'), ('VGWQ.AGG2.X2', 'agg2_x2'), ('VGWQ.AGG2.Y2', 'agg2_y2'), ('VGWQ.AGG.FWHM', 'agg_fwhm'), ('VGWQ.AGG.BRIGHT', 'agg_bright'), ('VGWQ.AGG.SKYLVL', 'agg_skylvl'), ('VGWQ.AGG.OBJX', 'agg_objx'), ('VGWQ.AGG.OBJY', 'agg_objy'), ('VGWQ.SVG.X1', 'svg_x1'), ('VGWQ.SVG.Y1', 'svg_y1'), ('VGWQ.SVG.X2', 'svg_x2'), ('VGWQ.SVG.Y2', 'svg_y2'), ('VGWQ.SVG.FWHM', 'svg_fwhm'), ('VGWQ.SVG.BRIGHT', 'svg_bright'), ('VGWQ.SVG.SKYLVL', 'svg_skylvl'), ('VGWQ.SVG.OBJX', 'svg_objx'), ('VGWQ.SVG.OBJY', 'svg_objy'), ('VGWQ.SVE.X1', 'sve_x1'), ('VGWQ.SVE.Y1', 'sve_y1'), ('VGWQ.SVE.X2', 'sve_x2'), ('VGWQ.SVE.Y2', 'sve_y2'), ('VGWQ.SVE.EXPTIME', 'sve_exptime'), ('VGWQ.SVE.FWHM', 'sve_fwhm'), ('VGWQ.SVE.BRIGHT', 'sve_bright'), ('VGWQ.SVE.SKYLVL', 'sve_skylvl'), ('VGWQ.SVE.OBJX', 'sve_objx'), ('VGWQ.SVE.OBJY', 'sve_objy'), ('VGWQ.SVGSR.DATE', 'svgsr_date'), ('VGWQ.SVGSR.RESULT', 'svgsr_result'), ('VGWQ.SVGSR.REL.RA', 'svgsr_rel_ra'), ('VGWQ.SVGSR.REL.DEC', 'svgsr_rel_dec'), ('VGWQ.SHG.ABS.RA', 'shg_abs_ra'), ('VGWQ.SHG.ABS.DEC', 'shg_abs_dec'), ('VGWQ.SHG.EQUINOX', 'shg_equinox'), ('VGWQ.SHG.EXPTIME_AG', 'shg_exptime_ag'), ('VGWQ.SHG.EXPTIME_SH', 'shg_exptime_sh')])
        
        # Register our table:
        self.stat.VGWQ = self.ocs.addStatusTable('VGWQ', ['agp_rel_ra', 'agp_rel_dec', 'agp_equinox', 'agp_abs_ra', 'agp_abs_dec', 'agp_mag', 'agp_object', 'svp_rel_ra', 'svp_rel_dec', 'svp_equinox', 'svp_abs_ra', 'svp_abs_dec', 'svp_abs_mm', 'svtm_rel_ra', 'svtm_rel_dec', 'svtm_dst_equinox', 'svtm_tgt_ra', 'svtm_tgt_dec', 'svtm_tgt_x', 'svtm_tgt_y', 'svtm_dst_ra', 'svtm_dst_dec', 'svtm_dst_x', 'svtm_dst_y', 'age_x1', 'age_y1', 'age_x2', 'age_y2', 'age_exptime', 'age_fwhm', 'age_bright', 'age_skylvl', 'age_objx', 'age_objy', 'agg1_x1', 'agg1_y1', 'agg1_x2', 'agg1_y2', 'agg2_x1', 'agg2_y1', 'agg2_x2', 'agg2_y2', 'agg_fwhm', 'agg_bright', 'agg_skylvl', 'agg_objx', 'agg_objy', 'svg_x1', 'svg_y1', 'svg_x2', 'svg_y2', 'svg_fwhm', 'svg_bright', 'svg_skylvl', 'svg_objx', 'svg_objy', 'sve_x1', 'sve_y1', 'sve_x2', 'sve_y2', 'sve_exptime', 'sve_fwhm', 'sve_bright', 'sve_skylvl', 'sve_objx', 'sve_objy', 'svgsr_date', 'svgsr_result', 'svgsr_rel_ra', 'svgsr_rel_dec', 'shg_abs_ra', 'shg_abs_dec', 'shg_equinox', 'shg_exptime_ag', 'shg_exptime_sh'], fmt_VGWQ, map_VGWQ)

        # Set initial values
        self.ocs.setStatus('VGWQ', agp_rel_ra='', agp_rel_dec='', agp_equinox=0.0, agp_abs_ra='', agp_abs_dec='', agp_mag=0.0, agp_object='',
                           svp_rel_ra='', svp_rel_dec='', svp_equinox=0.0, svp_abs_ra='', svp_abs_dec='', svp_abs_mm=0.0,
                           svtm_rel_ra='', svtm_rel_dec='', svtm_dst_equinox=0.0, svtm_tgt_ra='', svtm_tgt_dec='', svtm_tgt_x=0.0, svtm_tgt_y=0.0, svtm_dst_ra='', svtm_dst_dec='', svtm_dst_x=0.0, svtm_dst_y=0.0,
                           age_x1=0, age_y1=0, age_x2=0, age_y2=0, age_exptime=0, age_fwhm=0.0, age_bright=0.0, age_skylvl=0.0, age_objx=0.0, age_objy=0.0,
                           agg1_x1=0, agg1_y1=0, agg1_x2=0, agg1_y2=0, agg2_x1=0, agg2_y1=0, agg2_x2=0, agg2_y2=0, agg_fwhm=0.0, agg_bright=0.0, agg_skylvl=0.0, agg_objx=0.0, agg_objy=0.0,
                           svg_x1=0, svg_y1=0, svg_x2=0, svg_y2=0, svg_fwhm=0.0, svg_bright=0.0, svg_skylvl=0.0, svg_objx=0.0, svg_objy=0.0,
                           sve_x1=0, sve_y1=0, sve_x2=0, sve_y2=0, sve_exptime=0, sve_fwhm=0.0, sve_bright=0.0, sve_skylvl=0.0, sve_objx=0.0, sve_objy=0.0,
                           svgsr_date='', svgsr_result='', svgsr_rel_ra='', svgsr_rel_dec='', shg_abs_ra='', shg_abs_dec='', shg_equinox=0.0, shg_exptime_ag=0, shg_exptime_sh=0)

        self.parsetbl = {
            'agp': self.make_parse_table('VGWQ', (
            'agp_rel_ra', 'agp_rel_dec', 'agp_equinox', 'agp_abs_ra', 'agp_abs_dec', 'agp_mag',
            'agp_object')),

            'svp': self.make_parse_table('VGWQ', (
            'svp_rel_ra', 'svp_rel_dec', 'svp_equinox', 'svp_abs_ra', 'svp_abs_dec', 'svp_abs_mm')),

            'svtm': self.make_parse_table('VGWQ', (
            'svtm_rel_ra', 'svtm_rel_dec', 'svtm_dst_equinox', 'svtm_tgt_ra', 'svtm_tgt_dec',
            'svtm_tgt_x', 'svtm_tgt_y', 'svtm_dst_ra', 'svtm_dst_dec', 'svtm_dst_x', 'svtm_dst_y')),

            'age': self.make_parse_table('VGWQ', (
            'age_x1', 'age_y1', 'age_x2', 'age_y2', 'age_exptime', 'age_fwhm', 'age_bright',
            'age_skylvl', 'age_objx', 'age_objy')),

            'agg': self.make_parse_table('VGWQ', (
            'agg2_x2', 'agg2_y2', 'agg_fwhm', 'agg1_x1', 'agg1_y1', 'agg1_x2', 'agg1_y2',
            'agg2_x1', 'agg2_y1', 'agg_bright', 'agg_skylvl', 'agg_objx', 'agg_objy')),
        
            'svg': self.make_parse_table('VGWQ', (
            'svg_x1', 'svg_y1', 'svg_x2', 'svg_y2', 'svg_fwhm', 'svg_bright', 'svg_skylvl',
            'svg_objx', 'svg_objy')),

            'sve': self.make_parse_table('VGWQ', (
            'sve_x1', 'sve_y1', 'sve_x2', 'sve_y2', 'sve_exptime', 'sve_fwhm', 'sve_bright',
            'sve_skylvl', 'sve_objx', 'sve_objy')),

            'svgsr': self.make_parse_table('VGWQ', (
            'svgsr_date', 'svgsr_result', 'svgsr_rel_ra', 'svgsr_rel_dec')),

            'shg': self.make_parse_table('VGWQ', (
            'shg_abs_ra', 'shg_abs_dec', 'shg_equinox', 'shg_exptime_ag', 'shg_exptime_sh')),
            
            }

        # Will be set to periodic status task
        self.status_task = None

        # Data structure used for handing saves
        self.saves = {}
        for agtype in Ag.ag_types:
            bnch = Bunch.Bunch(lock=threading.RLock(),
                               ev_cancel=threading.Event(),
                               ev_done=threading.Event())
            bnch.ev_done.set()
            self.saves[agtype] = bnch

        # Holds information about running commands
        self.cmdHist = {}

        
    def start(self, wait=True):
        super(VGW, self).start(wait=wait)
        
        self.logger.info("VGW STARTED.")
        # Start auto-generation of status task
        t = common.IntervalTask(self.putstatus, self.param.status_interval)
        #self.status_task = t
        #t.init_and_start(self)

        self.logger.debug("Creating and starting controller.")
        self.controller = AgData.GuiderControl(self.logger, self.threadPool,
                                               self)
        self.controller.start()

        self.logger.debug("Creating and starting display.")
        self.maindisp = AgGUI.AgMainWindow(self.controller,
                                           self.logger, self.ev_quit,
                                           self.viewerName)
        #self.fv = self.maindisp.create_gui()

        self.viewer = ro.remoteObjectProxy(self.viewerName)

    def stop(self, wait=True):
        super(VGW, self).start(wait=wait)
        
        # Terminate status generation task
        if self.status_task != None:
            self.status_task.stop()

        self.status_task = None

        for agtype in Ag.ag_types:
            self.stop_interface(agtype)

        self.logger.info("VGW STOPPED.")


    def ui(self, options, args, ev_quit, logger=None):
        # user interface is handled in AgGUI
        return AgGUI.MainGUI(options, args, ev_quit, logger=self.logger)
        #return self.maindisp.mainloop()


    def dispatchCommand(self, tag, cmdName, args, kwdargs):
        self.logger.debug("tag=%s cmdName=%s args=%s kwdargs=%s" % (
            tag, cmdName, str(args), str(kwdargs)))

        params = {}
        params.update(kwdargs)
        params['tag'] = tag
        
        try:
            # Try to look up the named method
            method = getattr(self, cmdName)

        except AttributeError, e:
            result = "ERROR: No such method in subsystem: %s" % (cmdName)
            self.logger.error(result)
            raise CamCommandError(result)

        # Check if we are in local mode
        if self.mode == 'local':
            result = "Instrument is in LOCAL mode"
            self.logger.error(result)
            raise CamCommandError(result)

        self.cmdHist[tag] = Bunch.Bunch(cmdName=cmdName, params=params,
                                        gui=None)
        return method(*args, **params)

    def cancelCommand(self, tag):
        try:
            # Try to look up the named method
            cmdInfo = self.cmdHist[tag]
            self.logger.debug("cancel command: found info on command '%s'" % (
                cmdInfo.cmdName))
            if cmdInfo.gui != None:
                self.fv.gui_do(cmdInfo.gui.cancel)

        except KeyError, e:
            self.logger.error("No information in history about tag '%s'" % (
                tag))

    def addCmdInfo(self, tag, **kwdargs):
        cmdInfo = self.cmdHist[tag]
        cmdInfo.update(kwdargs)
        
    #######################################
    # INTERNAL METHODS
    #######################################

    def change_mode(self, mode):
        if not (mode in ('slave', 'local')):
            raise VGWError("Bad mode: '%s': must be one of {slave,local}" % (
                mode))
        with self.lock:
            self.mode = mode
            self.ocs.setStatus('VGWD', run1=mode.upper())

    def format_time(self, time_t=None, format=None):
        if time_t == None:
            time_t = time.time()
        if format == None:
            return time2timestamp(time_t)
        return time.strftime(format, time.localtime(time_t))
    
    def _getstatus(self, setname):
        setname = setname.upper()
        statusDict = {}
        statusDict.update(self.statusset[setname])

        try:
            self.ocs.requestOCSstatus(statusDict, timeout=10.0)

        except CamInterfaceError, e:
            raise VGWError("Error fetching status from OCS: %s" % (
                str(e)))

        self.ocsstatus.update(statusDict)
        
    def getFrameInfo(self, frame_no):
	if ':' in frame_no:
	    (frame_no, num_frames) = frame_no.split(':')
	    num_frames = int(num_frames)
        else:
            num_frames = 1

        # Check frame_no
        match = re.match('^(\w{3})(\w)(\d{8})$', frame_no)
        if not match:
            raise VGWError("Error in frame_no: '%s'" % frame_no)

	inst_code = match.group(1)
	frame_type = match.group(2)
        # Convert number to an integer
        try:
            frame_cnt = int(match.group(3))
        except ValueError, e:
            raise VGWError("Error in frame_no: '%s'" % frame_no)

        return (inst_code, frame_type, frame_cnt, num_frames)

    def get_iHost(self, v_lan_data):
        """Return the "index" of this v_lan_data type.  This is used by
        some of the TCL scripts."""
        try:
            iHost = { 'AG': 0, 'SV': 1, 'SH': 2, }[v_lan_data]
            return iHost
        except KeyError:
            raise VGWCommandError("Unknown type for V_LAN_DATA param: should be AG|SV|SH")

    def none2nop(self, *args):
        res = []
        for val in args:
            if val == None:
                res.append('NOP')
            else:
                res.append(val)
        return res
    
    def make_parse_table(self, tableName, aliases, offset_sep=1):
        tableBnch = self.ocs.getInternalStatusInfo(tableName)
        formatStr = tableBnch.formatStr

        def cvtint(x):
            try:
                return int(x)
            except Exception:
                # if using g2cam, should return ##STATERROR## or ##STATNONE##
                return 0

        def cvtfloat(x):
            try:
                return float(x)
            except Exception:
                # if using g2cam, should return ##STATERROR## or ##STATNONE##
                return 0.0
            
        converters = { 'd': cvtint, 'f': cvtfloat, 's': str }

        # Sort the aliases to find out what order they need to be parsed
        l = []
        for alias in aliases:
            try:
                i = formatStr.index(alias)
            except ValueError:
                raise VGWError("Failed to build parse table--bad index (%d) for alias '%s'" % (
                    i, alias))
            l.append((alias, i))
        l.sort(lambda x, y: cmp(x[1], y[1]))

        # Now go through and build a parse table of tuples (alias, start, stop, type)
        offset = 0
        parsetbl = []
        for alias, index in l:
            regex = r'^.*\%\(' + alias + r'\)(?P<width>\d+)(?P<precision>\.\d+)?(?P<type>\w)'
            match = re.match(regex, formatStr)
            if not match:
                raise VGWError("Failed to build parse table--no RE match (%s) for alias '%s'" % (
                    regex, alias))

            width = int(match.group('width'))
            start = offset
            offset += width
            stop = offset
            # Assume 
            offset += offset_sep
            try:
                dtype = match.group('type')
                cvt = converters[dtype]
            except KeyError:
                raise VGWError("Failed to build parse table--no converter (%s) for alias '%s'" % (
                    dtype, alias))
            parsetbl.append((alias, start, stop, cvt))

        print tableName, parsetbl
        return parsetbl
                
    def update_status_VGWD(self, agkey, count, quality):
        time_s = self.format_time()

        if not quality:
            # NOTE: this should probably be an error, but we could only
            # set that if using g2cam
            fwhm = 0.0
        else:
            # ?? should this be quality.fwhm ??
            fwhm = quality.starsize
            
        if agkey in ('AG', 'FMOS', 'HSCSCAG'):
            # TODO: give FMOS and HSC their own status values?
            self.ocs.setStatus('VGWD', disp_ag=count, fwhm_ag=fwhm,
                               fwhm_time_ag=time_s)
            self.putstatus(target='VGWD')
            
        elif agkey in ('SV',):
            self.ocs.setStatus('VGWD', disp_sv=count, fwhm_sv=fwhm,
                               fwhm_time_sv=time_s)
            self.putstatus(target='VGWD')
            

    def pix2ccd(self, x1, y1, iBin, iX, iY):
        ## x = iX + ((x1-1) * iBin)
        ## y = iY + ((y1-1) * iBin)
        x = iX + (x1 * iBin)
        y = iY + (y1 * iBin)
        return (x, y)

    def write_fits(self, fitspath, image, object, frameid,
                   overwrite=False):
        # calculate any missing FITS headers
        self.logger.debug("updating header")
        self.update_header(image, object, frameid)

        if overwrite:
            try:
                os.remove(fitspath)
            except OSError:
                pass

        self.logger.debug("Writing fits to %s" % (fitspath))
        image.write_fits(fitspath)


    def data_cb(self, agkey, count, image):

        quality = image.get('quality', None)
        self.update_status_VGWD(agkey, count, quality)

        ## if (agkey == 'SV'):
        ##     # calculate offset from previous SV centroid
        ##     # svgsr_date, svgsr_result, svgsr_rel_ra, svgsr_rel_dec
        ##     self.qdasvgw_result_to_local_status('VGWQ', lines[2],
        ##                                         self.parsetbl['svgsr'])
        ##     self.putstatus('VGWQ')

    def clear_queue(self, agkey):
        try:
            # tell controller not to save any more images to the queue
            self.controller.reset_image_n(agkey)
            # now flush the queue
            while True:
                self.controller.get_image(agkey, block=False)
        except Exception, e:
            pass
        
    def save_queue(self, agtype, inst_code, frame_type, frame_cnt,
                   num_frames, objname):

        if not objname:
            objname = agtype

        bnch = self.saves[agtype]
        try:
            with bnch.lock:
                if bnch.ev_cancel.isSet():
                    return
                bnch.ev_done.clear()

            # inform controller of our desire to get N images
            self.controller.save_image_n(agtype, num_frames)

            # pull N images and make a file from each one
            i = 0
            while (i < num_frames) and (not bnch.ev_cancel.isSet()):
                try:
                    image = self.controller.get_image(agtype, block=True,
                                                      timeout=0.1)
                except Queue.Empty:
                    continue

                if frame_cnt:
                    frameid = '%s%s%08d' % (inst_code, frame_type, frame_cnt + i)
                else:
                    frameid = self.ocs.getFrame(frame_type)
                self.logger.debug("got image %s" % (frameid))

                # calculate any missing FITS headers
                self.logger.debug("updating header")
                self.update_header(image, objname, frameid)

                path = os.path.join(self.param.fitsdir, "%s.fits" % frameid)
                self.logger.debug("Writing fits to %s" % (path))
                image.write_fits(path)

                # Archive the file to the OCS
                self.ocs.archive_frame(frameid, path)

                i += 1
        finally:
            with bnch.lock:
                bnch.ev_done.set()
                bnch.ev_cancel.clear()

    def cancel_save(self, agtype):
        bnch = self.saves[agtype]

        wait = False
        with bnch.lock:
            if not bnch.ev_done.isSet():
                # another task is busy saving files
                self.logger.info("Trying to cancel running save of %s images..." % (
                    agtype))
                wait = True
                bnch.ev_cancel.set()

        if wait:
            # wait 5 sec or until other task finishes, whichever comes first
            bnch.ev_done.wait(5.0)
            if not bnch.ev_done.isSet():
                raise VGWError("Another task is saving images and won't cancel!")
            
        # clear out controller's queue of images
        self.clear_queue(agtype)

        
    def update_header(self, image, objname, frameid):
        ## self.logger.debug("Getting metadata")
        ## agheader, agtime, status = image.get_list('agheader', 'time', 'status')

        ## p = gfh.GuiderFitsParams(self.fitshelper, agheader=agheader,
        ##                          agtime=agtime, status=status)
        image.update_keywords({ 'OBJECT': objname,
                                'FRAMEID': frameid,
                                'EXP-ID': frameid,
                                })
        image.set(deriver=self.fitshelper)

        status = image.get('status')
        self.logger.debug("status is %s" % (str(status)))

    def save_tmp_file(self, agsrc, agtype, filename):
        image = self.controller.get_saved_image(agsrc)

        # calculate any missing FITS headers
        self.logger.debug("updating header")
        self.update_header(image, agtype, 'VGWQ00000000')

        vgwconf = g2soss.daqvgwhome
        fitspath = os.path.join(vgwconf, 'fitsdat', filename)
        try:
            os.remove(fitspath)
        except OSError:
            pass
        self.logger.debug("Writing fits to %s" % (fitspath))
        image.write_fits(fitspath)

    def get_default_parameters(self, key, varDict, varList):
        try:
            varDict.update(self.default_parameters[key])
        except KeyError:
            pass

    #######################################
    # VGW INSTRUMENT COMMANDS
    #######################################

    def putstatus(self, target="VGWD", tag=None):
        """Forced export of our status.
        """
	# Bump our status send count and time
        ## tbl = self.stat[target]
        ## self.stattbl1.count += 1
        ## self.stattbl1.time = time.strftime("%4Y%2m%2d %2H%2M%2S",
        ##                                time.localtime())
        if target == 'ALL':
            self.ocs.exportStatus()

        else:
            self.ocs.exportStatusTable(target)


    def getstatus(self, target="ALL", tag=None):
        """Forced import of our status using the normal status interface.
        """
        if target != 'ALL':
            self._getstatus(target)
        else:
            for target in self.statusset.keys():
                self._getstatus(target)
                
        self.logger.info("Status returned: %s" % (str(self.ocsstatus)))

    def restart(self, motor=None):
        self.ocs.reload_and_restart('VGW')

    def call_viewer(self, methodName, *args, **kwdargs):
        return self.viewer.callGlobalPlugin("foo", "VGW", methodName, args,
                                            kwdargs)

    def ag_auto_select(self, motor=None, equinox=None, ra=None, dec=None,
                       f_select=None, probe_ra=None, probe_dec=None,
                       ag_pa=None, probe_r=None, probe_theta=None,
                       probe_x=None, probe_y=None, select_mode=None,
                       dss_mode=None, ag_area=None, instrument_name=None,
                       limitmag=None, goodmag=None, fov_pattern=None,
                       tag=None):
        if motor.upper() != 'ON':
            return

        res = self.call_viewer('ag_auto_select', tag,
                               motor=motor, equinox=equinox, ra=ra, dec=dec,
                               f_select=f_select, probe_ra=probe_ra,
                               probe_dec=probe_dec, ag_pa=ag_pa,
                               probe_r=probe_r, probe_theta=probe_theta,
                               probe_x=probe_x, probe_y=probe_y,
                               select_mode=select_mode, dss_mode=dss_mode,
                               ag_area=ag_area, instrument_name=instrument_name,
                               limitmag=limitmag, goodmag=goodmag,
                               fov_pattern=fov_pattern)
    
        p = Bunch.Bunch(res)
        if p.result == 'cancel':
            raise VGWError("Command cancelled.")
        elif p.result == 'error':
            raise VGWError(p.errmsg)

## $RESULT(ra_off),$RESULT(dec_off),$RESULT(equinox),$RESULT(ra),$RESULT(dec),$RESULT(mag),$RESULT(object)
## $RESULT(x1) $RESULT(y1) $RESULT(x2) $RESULT(y2),$RESULT(exptime),$RESULT(data_fwhm),$RESULT(data_bright)
## $RESULT(ag1_x1) $RESULT(ag1_y1) $RESULT(ag1_x2) $RESULT(ag1_y2),$RESULT(ag2_x1) $RESULT(ag2_y1) $RESULT(ag2_x2) $RESULT(ag2_y2),$RESULT(detect_fwhm),$RESULT(detect_bright)"
        ## # Store status
        ## # overlaps PROBE_POSITION results
        ## # agp_rel_ra, agp_rel_dec, agp_equinox, agp_abs_ra, agp_abs_dec,
        ## # agp_mag, agp_object
        ## self.qdasvgw_result_to_local_status('VGWQ', lines[2],
        ##                                     self.parsetbl['agp'])
        params = dict(agp_rel_ra=p.ra_off, agp_rel_dec=p.dec_off,
                      agp_equinox=p.equinox,
                      agp_abs_ra=p.star_ra, agp_abs_dec=p.star_dec,
                      agp_mag=p.star_mag, agp_object=p.star_name)

        self.ocs.setStatusDict('VGWQ', params)
        
        ## # overlaps REGION_SELECTION results
        ## # age_x1, age_y1, age_x2, age_y2, age_exptime, age_fwhm, age_bright,
        ## # age_skylvl, age_objx, age_objy
        ## self.qdasvgw_result_to_local_status('VGWQ', lines[3],
        ##                                     self.parsetbl['age'])
        params = dict(age_x1=p.exp_x1, age_y1=p.exp_y1,
                      age_x2=p.exp_x2, age_y2=p.exp_y2,
                      age_exptime=p.exp_time, age_fwhm=0.0, age_bright=0.0)

        self.ocs.setStatusDict('VGWQ', params)
        
        ## # overlaps AG_GUIDE_AREA_SELECTION results
        ## # agg1_x1, agg1_y1, agg1_x2, agg1_y2, agg2_x1, agg2_y1, agg2_x2,
        ## # agg2_y2, agg_fwhm, agg_bright, agg_skylvl, agg_objx, agg_objy
        ## self.qdasvgw_result_to_local_status('VGWQ', lines[4],
        ##                                     self.parsetbl['agg'])
        if ag_area == 'AG1':
            params = dict(agg1_x1=p.ag_x1, agg1_y1=p.ag_y1,
                          agg1_x2=p.ag_x2, agg1_y2=p.ag_y2,
                          agg_fwhm=0.0, agg_bright=0.0)
        elif ag_area == 'AG2':
            params = dict(agg2_x1=p.ag_x1, agg2_y1=p.ag_y1,
                          agg2_x2=p.ag_x2, agg2_y2=p.ag_y2,
                          agg_fwhm=0.0, agg_bright=0.0)

        self.ocs.setStatusDict('VGWQ', params)
        self.putstatus('VGWQ')

        
    def ag_guide_area_selection(self, motor=None, select_mode=None,
                                x_region=None, y_region=None, ag_area=None,
                                tag=None):
        if motor.upper() != 'ON':
            return

        # For now...
        v_lan_data = 'AG'

        res = self.call_viewer('ag_guide_area_selection', tag, motor=motor,
                               select_mode=select_mode, v_lan_data=v_lan_data,
                               x_region=x_region, y_region=y_region,
                               ag_area=ag_area)

        p = Bunch.Bunch(res)
        if p.result == 'cancel':
            raise VGWError("Command cancelled.")
        elif p.result == 'error':
            raise VGWError(p.errmsg)

        params = dict(agg_fwhm=p.fwhm, agg_bright=p.brightness,
                      agg_skylvl=p.skylevel,
                      agg_objx=p.objx, agg_objy=p.objy)

        # Convert pixel coords on image back to CCD coords
        x1, y1 = p.ccd_x1, p.ccd_y1
        x2, y2 = p.ccd_x2, p.ccd_y2

        # return the results via status values
        if ag_area == 'AG1':
            params.update(dict(agg1_x1=p.ccd_x1, agg1_y1=p.ccd_y1,
                               agg1_x2=p.ccd_x2, agg1_y2=p.ccd_y2))

        elif ag_area == 'AG2':
            params.update(dict(agg2_x1=p.ccd_x1, agg2_y1=p.ccd_y1,
                               agg2_x2=p.ccd_x2, agg2_y2=p.ccd_y2))

        self.ocs.setStatusDict('VGWQ', params)
        self.putstatus(target='VGWQ')
        return


    def mark_position(self, v_lan_data=None, x=None, y=None, mode=None,
                      mark=None, size=None, color=None, tag=None):
        self.call_viewer('mark_position', tag, v_lan_data=v_lan_data,
                         x=x, y=y, mode=mode, mark=mark, size=size,
                         color=color)

    def probe_position(self, motor=None, equinox=None, ra=None, dec=None,
                       f_select=None, probe_ra=None, probe_dec=None,
                       ag_pa=None, tag=None):
        raise VGWCommandError("PROBE_POSITION has been deprecated")

        
    def region_selection(self, motor=None, v_lan_data=None, select_mode=None,
                         x_region=None, y_region=None, tag=None):
        if motor.upper() != 'ON':
            return

        res = self.call_viewer('region_selection', tag, motor=motor,
                             v_lan_data=v_lan_data, select_mode=select_mode,
                             x_region=x_region, y_region=y_region)

        p = Bunch.Bunch(res)
        if p.result == 'cancel':
            raise VGWError("Command cancelled.")
        elif p.result == 'error':
            raise VGWError(p.errmsg)

        # Convert pixel coords on image back to CCD coords
        x1, y1 = p.ccd_x1, p.ccd_y1
        x2, y2 = p.ccd_x2, p.ccd_y2
        objx, objy = p.ccd_objx, p.ccd_objy
        self.logger.info("objx,objy=%f,%f" % (p.ccd_objx, p.ccd_objy))

        # return the results via status values
        if v_lan_data in ('AG', 'FMOS', 'HSCSCAG'):
            params = dict(age_x1=x1, age_y1=y1,
                          age_x2=x2, age_y2=y2,
                          age_exptime=p.exptime, age_fwhm=p.fwhm,
                          age_bright=p.brightness,
                          age_skylvl=p.skylevel,
                          age_objx=objx, age_objy=objy)

        elif v_lan_data in ('SV'):
            params = dict(sve_x1=x1, sve_y1=y1,
                          sve_x2=x2, sve_y2=y2,
                          sve_exptime=p.exptime, sve_fwhm=p.fwhm,
                          sve_bright=p.brightness,
                          sve_skylvl=p.skylevel,
                          sve_objx=objx, sve_objy=objy)

        self.ocs.setStatusDict('VGWQ', params)
        self.putstatus(target='VGWQ')
        return

    def save_every_data(self, motor=None, v_lan_data=None, frame_num=None,
                        tag=None):
        if motor.upper() != 'ON':
            return
        agtype = v_lan_data

        # try to cancel previous saving task, if any
        self.cancel_save(agtype)
            
        task = Task.FuncTask(self.save_queue, (agtype, 'VGW', 'A', None,
                                               frame_num, None),
                             {},
                             logger=self.logger)
        task.init_and_start(self)
        # don't wait for completion


    def save_v_lan_frame(self, motor=None, v_lan_data=None, frame_no=None,
                         object=None, tag=None):
        if motor.upper() != 'ON':
            return
        agtype = v_lan_data

        (inst_code, frame_type, frame_cnt,
         num_frames) = self.getFrameInfo(frame_no)
        self.logger.debug("image count is %d" % (num_frames))

        # try to cancel previous saving task, if any
        self.cancel_save(agtype)
            
        task = Task.FuncTask(self.save_queue, (agtype, inst_code, frame_type,
                                               frame_cnt, num_frames, object),
                             {},
                             logger=self.logger)
        task.init_and_start(self)
        res = task.wait()
        

    def sh_auto_select(self, motor=None, equinox=None, ra=None, dec=None,
                       select_mode=None, region=None, tag=None):
        if motor.upper() != 'ON':
            return

        res = self.call_viewer('sh_auto_select', tag,
                               motor=motor, equinox=equinox, ra=ra, dec=dec,
                               select_mode=select_mode, region=region)
    
        p = Bunch.Bunch(res)
        if p.result == 'cancel':
            raise VGWError("Command cancelled.")
        elif p.result == 'error':
            raise VGWError(p.errmsg)

        # Store status
        # shg_abs_ra, shg_abs_dec, shg_equinox, shg_exptime_ag,
        # shg_exptime_sh
        params = dict(shg_abs_ra=p.ra, shg_abs_dec=p.dec,
                      shg_equinox=p.equinox,
                      shg_exptime_ag=p.exp_ag, shg_exptime_sh=p.exp_sh)

        self.ocs.setStatusDict('VGWQ', params)
        self.putstatus('VGWQ')


    def slit_position(self, motor=None, equinox=None, ra=None, dec=None,
                      f_select=None, slit_mm=None, sv_pa=None,
                      imgrot_flg=None, tag=None):
        raise VGWCommandError("SLIT_POSITION has been deprecated")
        

    def sv_data_type(self, motor=None, type=None, tag=None):
        raise VGWCommandError("SV_DATA_TYPE has been deprecated")


    def sv_drive(self, motor=None, slit_x=None, slit_y=None, object_x=None,
                 object_y=None, tag=None):
        if motor.upper() != 'ON':
            return

        res = self.call_viewer('sv_drive', tag,
                               motor=motor, slit_x=slit_x, slit_y=slit_y, object_x=object_x, object_y=object_y)

        p = Bunch.Bunch(res)
        if p.result == 'cancel':
            raise VGWError("Command cancelled.")
        elif p.result == 'error':
            raise VGWError(p.errmsg)
    
        ## QDASvgwTelMove
        ##         CMD_PARA_SLIT_X,
        ##         CMD_PARA_SLIT_Y,
        ##         CMD_PARA_OBJECT_X,
        ##         CMD_PARA_OBJECT_Y,
        ## cmdstr = "QDASvgwTelMove.tcl %s %s %s %s %s %s %s %s %s" % (
        ##     #      iX,            iY,       iPixDX,     iPixDY,      iBin
        ##     agh.expRangeX, agh.expRangeY, agh.numPixX, agh.numPixY, agh.binX,
        ##     slit_x, slit_y, object_x, object_y)

        # Store status
        # svtm_rel_ra, svtm_rel_dec, svtm_dst_equinox(f), svtm_tgt_ra,
        # svtm_tgt_dec, svtm_tgt_x(f), svtm_tgt_y(f), svtm_dst_ra,
        # svtm_dst_dec, svtm_dst_x(f), svtm_dst_y(f)
        params = dict(svtm_rel_ra=p.rel_ra, svtm_rel_dec=p.rel_dec,
                      svtm_dst_equinox=p.equinox,
                      svtm_tgt_ra=p.object_ra, svtm_tgt_dec=p.object_dec,
                      svtm_tgt_x=p.object_x, svtm_tgt_y=p.object_y,
                      svtm_dst_ra=p.slit_ra, svtm_dst_dec=p.slit_dec,
                      svtm_dst_x=p.slit_x, svtm_dst_y=p.slit_y)

        self.ocs.setStatusDict('VGWQ', params)
        self.putstatus('VGWQ')


    def sv_guide_area_selection(self, motor=None, select_mode=None,
                                x_region=None, y_region=None, algorysm=None,
                                tag=None):
        raise VGWCommandError("SV_GUIDE_AREA_SELECTION has been deprecated")
        
    def sv_guide_signal_report(self, motor=None, action=None, x=None, y=None,
                               tag=None):
        raise VGWCommandError("SV_GUIDE_SIGNAL_REPORT has been deprecated")

    def vgw_mode(self, motor=None, mode=None, tag=None):
        raise VGWCommandError("VGW_MODE has been deprecated")

    def v_lan_data_fits_file(self, motor=None, v_lan_data=None, frame_no=None,
                             object=None, tag=None):
        if motor.upper() != 'ON':
            return
        agtype = v_lan_data

        if not object:
            object = agtype

        (inst_code, frame_type, frame_cnt,
         num_frames) = self.getFrameInfo(frame_no)
        if num_frames > 1:
            raise VGWCommandError("This command only supports saving one frame")
            
        image = self.controller.get_saved_image(agtype)

        frameid = '%s%s%08d' % (inst_code, frame_type, frame_cnt)
        self.logger.debug("got image %s" % (frameid))

        aliasList = (('PROP-ID', 'FITS.VGW.PROP-ID'),
                     ('OBSERVER', 'FITS.VGW.OBSERVER'), )
        statusDict = {}.fromkeys(map(lambda x: x[1], aliasList), 0)
        try:
            self.ocs.requestOCSstatus(statusDict, timeout=10.0)

        except CamInterfaceError, e:
            raise VGWError("Error fetching status from OCS: %s" % (
                str(e)))
        
        # Replace some FITS headers with newer status
        header = image.get_header()
        for kwd, alias in aliasList:
            if header.has_key(alias):
                #statusDict[alias] = fetchDict[alias]
                header[kwd] = statusDict[alias]

        # calculate any missing FITS headers
        self.logger.debug("updating header")
        self.update_header(image, object, frameid)
            
        path = os.path.join(self.param.fitsdir, "%s.fits" % frameid)
        self.logger.debug("Writing fits to %s" % (path))
        image.write_fits(path)

        # Archive the file to the OCS
        self.ocs.archive_frame(frameid, path)
        

    def v_lan_mode(self, motor=None, v_lan_data=None, calib_flag=None,
                   intgral_count=None, tag=None):
        # Essentially a NOP
        if motor.upper() != 'ON':
            return
        
        agkey = v_lan_data.upper()

        if calib_flag.upper() != 'OFF':
            raise VGWCommandError("CALIB_FLAG=ON is not supported for this command")

        if intgral_count != 1:
            raise VGWCommandError("INTGRAL_COUNT>1 is not supported for this command")

#END VGW.py
