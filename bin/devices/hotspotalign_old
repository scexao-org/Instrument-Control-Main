#!/usr/bin/env python

# ============================================================= #
#              _                   _       _   _ _              #
#   /\  /\___ | |_ ___ _ __   ___ | |_    /_\ | (_) __ _ _ __   #
#  / /_/ / _ \| __/ __| '_ \ / _ \| __|  //_\\| | |/ _` | '_ \  #
# / __  / (_) | |_\__ \ |_) | (_) | |_  /  _  \ | | (_| | | | | #
# \/ /_/ \___/ \__|___/ .__/ \___/ \__| \_/ \_/_|_|\__, |_| |_| #
#                     |_|                          |___/        #
#                                                               #
# ============================================================= #

import os
import time
import sys
import pdb
import numpy as np
from astropy.io import fits as pf
import numpy.linalg as la

from scxkw.config import REDIS_DB_HOST, REDIS_DB_PORT
from scxkw.redisutil.typed_db import Redis

home = os.getenv('HOME')
sys.path.append(home+'/src/lib/python/')
from camera_tools import cam_cmd
#from xaosim.scexao_shmlib import shm
#from scexao_shm import shm
from pyMilk.interfacing.isio_shmlib import SHM as shm
import ezstep_chain3 as ezstep_chain

ttmdev  = "/dev/serial/by-path/"
ttmdev += "pci-0000:00:1d.0-usb-0:1.8.2:1.0-port0" # all steppers now connected together

shm_im = shm("ircam0")
shm_im_dark = shm("ircam0_dark")
shm_im_badpixmap = shm("ircam0_badpixmap")

# Reading in shared memory
#------------------------

def read_shm():
    im_chuck = shm_im.get_data().astype('float32')
    dark_chuck = shm_im_dark.get_data()
    badpixmap_chuck = shm_im_badpixmap.get_data()
    im_chuck -= dark_chuck
    im_chuck *= badpixmap_chuck
    return im_chuck

# ------------------------------------------------------------------
#  Read database for some stage status
# ------------------------------------------------------------------
def RDB_pull(rdb):

    fits_keys_to_pull = {'X_NULPKO'}
    # Now Getting the keys
    with rdb.pipeline() as pipe:
        for key in fits_keys_to_pull:
            pipe.hget(key, 'FITS header')
            pipe.hget(key, 'value')
        values = pipe.execute()
    status = {k: v for k,v in zip(values[::2], values[1::2])}

    gpin = status['X_NULPKO'].strip() == 'IN'

    return(gpin)

# Find center of image
#------------------------

def find_center(shiftx, shifty):
    for i in range(100):
        if i == 0:
            im_chuck = read_shm()/100.
        else:
            im_chuck += read_shm()/100.
    #imin = np.percentile(im_chuck, 99.97)
    iflux = np.percentile(im_chuck, 99.999)
    imin = iflux*0.01
    print(imin, iflux, np.max(im_chuck))
    im_chuck = im_chuck-imin
    mask = im_chuck > 0
    im_chuck = im_chuck*mask
    if iflux < 200:
        print("Not enough flux, aborting")
        os.system("/home/scexao/bin/log Hotspotalign: Not enough flux, aborting")
        os.system("scexaostatus set hotspot 'LOW FLUX' 0")
        sys.exit()
    #pf.writeto("./temp_chuck.fits",im_chuck,clobber='True')
    total = np.sum(im_chuck)
    X, Y = np.indices(np.shape(im_chuck)) 
    cx = (np.sum(Y*im_chuck)/total)
    cy = (np.sum(X*im_chuck)/total)
    cx = cx-shiftx
    cy = cy-shifty
    return [cx, cy]

# Main
#------------------------

# ------------------------------------------------------------------
#            Configure communication with SCExAO's redis
# ------------------------------------------------------------------
rdb = Redis(host=REDIS_DB_HOST, port=REDIS_DB_PORT)
# Is the server alive ?
try:
    alive = rdb.ping()
    if not alive:
        raise ConnectionError
except:
    print('Error: can\'t ping redis DB.')
    sys.exit(1)

gpin = RDB_pull(rdb)

# parameters of the target point
with open('/home/scexao/conf/chuckcam_aux/hotspots.txt') as file:
    pos = np.array([[float(digit) for digit in line.split()] for line in file])

pscale = 15.3 #mas per pixel in Chuckcam

filename = "/home/scexao/conf/chuckcam_aux/hotspots_cor.txt"
cors = [line.rstrip('\n') for line in open(filename)]
ncor = len(cors)
cort = np.zeros((2,ncor))
for i in range(ncor):
    corparam = cors[i].split(';')
    cort[0,i] = float(corparam[2])
    cort[1,i] = float(corparam[3])
cort /= pscale
cor = np.array([0,0])
if gpin:
    cor = cort[:,0]

im_chuck = read_shm()
(ysize,xsize) = im_chuck.shape
print(xsize, ysize)
crop = shm_im.get_crop().astype(int)
#crop = np.array([128,128,160,160])
shiftx = pos[0,0]-crop[0]+320+cor[0]-0.5
shifty = pos[0,1]-crop[2]+256+cor[1]-0.5
print( shiftx, shifty)
# parameters of the loop
gain = 0.2
precision = 0.2

os.system("/home/scexao/bin/log Hotspotalign: starting alignment")
os.system("scexaostatus set hotspot 'IN PROGRESS' 3")

#reset the steering mirror
os.system("steering home")
time.sleep(1)
os.system("steering onaxis")
time.sleep(1)

A = np.matrix([[-8.8/100., -0.0/100.],[0.0/100., -4.7/100.]])
invA = la.inv(A)

# Try to find the center a first time, to check the flux
c0 = find_center(shiftx, shifty)
# move a first time in negative values in x and y
ttm = ezstep_chain.ezstep_chain(ttmdev)
ttm.dmove(1, -100)
time.sleep(0.1)
ttm.dmove(2, -100)
time.sleep(0.1)

#initialize the position
cnt = 0
c0 = find_center(shiftx, shifty)
print(c0)

# loop
while (((c0[0]**2+c0[1]**2)**0.5) > precision) and (cnt < 500):
    cnt = cnt+1
    c0 = find_center(shiftx, shifty)
    print(c0)
    
    # if the psf is still north-west of the hotspot, move south-east
    if (c0[0] > precision) and (c0[1] > precision):
        ttm.dmove(1, -100)
        time.sleep(0.1)
        ttm.dmove(2, -100)
        if cnt > 20:
            precision = precision+0.05
    
    # if the psf is still south-west of the hotspot, move east
    elif (c0[0] > precision) and (c0[1] < precision):
        ttm.dmove(2, -100)
        if cnt > 20:
            precision = precision+0.05
    
    # if the psf is still north-east of the hotspot, move south
    elif (c0[0] < precision) and (c0[1] > precision):
        ttm.dmove(1, -100)
        if cnt > 20:
            precision = precision+0.05

    # else, if the psf is south-east of the hotspot, move closer to the hotspot
    else:
        com = np.dot(invA, c0)
        print(com)
        com0x = int(round(com[0,0]*gain))
        com0y = int(round(com[0,1]*gain))
        com0x = min([com0x, 100])
        com0y = min([com0y, 100])
        if (com0x > 0):
            ttm.dmove(2, com0x)
            time.sleep(0.1)
        if (com0y > 0):
            ttm.dmove(1, com0y)
            time.sleep(0.1)

# close the communication with the tip-tilt mount
ttm.close()
shm_im.close()

os.system("/home/scexao/bin/log Hotspotalign: alignment done")
os.system("scexaostatus set hotspot 'OFF' 1")
